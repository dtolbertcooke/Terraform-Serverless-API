name: Serverless API Terraform Pipeline
description: Builds serverless API infrastructure in the specified environment.

on:
  pull_request:
    branches: [dev, test, main]
  push:
    branches: [dev, test, main]
  workflow_dispatch: # Manual trigger included to allow manual runs if needed

permissions:
  id-token: write # Required for github oidc authentication with AWS
  contents: read # Allow repository contents to be checked out
  pull-requests: write # Allow PR comments with terraform plan

jobs:
  # First job: Tests & Lint (always runs)
  tests:
    name: Tests & Lint
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      # Checkout the repo
      - name: Checkout
        uses: actions/checkout@v4

      # Lambda app testing
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18" # same version as lambda functions

      - name: Install dependencies
        working-directory: app
        run: npm ci # clean install

      - name: Run lint
        working-directory: app
        run: npm run lint # ensure code style consistency

      - name: Run unit tests
        working-directory: app/tests
        run: npm test # execute Jest unit tests for lambda functions

      # Terraform checks
      # Install Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.2" # Pin to specific version of terraform

      - name: Terraform fmt check
        working-directory: infrastructure
        run: terraform fmt -check -recursive # enforce terraform formatting standards

      - name: Terraform Init # for validation
        working-directory: infrastructure
        run: terraform init -backend=false # doesn't affect state by skipping remote state; only validates modules/providers

      - name: Terraform validate
        working-directory: infrastructure
        run: terraform validate # validate terraform syntax

  # Second job: Terraform Plan (on PRs)
  plan:
    runs-on: ubuntu-latest
    needs: [tests] # only run if tests pass
    if: github.event_name == 'pull_request' # only run on PRs

    env:
      ENVIRONMENT: ${{ github.base_ref == 'main' && 'prod' ||
        github.base_ref == 'test' && 'test' ||
        github.base_ref == 'dev' && 'dev' }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    defaults:
      run:
        working-directory: infrastructure # Keep runs scoped to environment code

    steps:
      # Checkout the repo
      - name: Checkout
        uses: actions/checkout@v4

      # Configure AWS credentials using OIDC
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: "us-east-1" # default region just for the OIDC STS call; set actual region in step below
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-oidc-role-${{ env.ENVIRONMENT }}

      # Fetch backend config from SSM
      # - Retrieves global S3/DynamoDB state backend
      # - Creates backend config file for terraform init
      - name: Fetch Backend Config
        run: |
          STATE_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/state-bucket" --query "Parameter.Value" --output text)
          STATE_TABLE=$(aws ssm get-parameter --name "/tf/global-backend/state-table" --query "Parameter.Value" --output text)
          REGION=$(aws ssm get-parameter --name "/tf/global-backend/region" --query "Parameter.Value" --output text)
          DEV_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-dev" --query "Parameter.Value" --output text)
          TEST_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-test" --query "Parameter.Value" --output text)
          PROD_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-prod" --query "Parameter.Value" --output text)

          echo "TF_VAR_state_bucket_name=$STATE_BUCKET" >> $GITHUB_ENV
          echo "DEV_LAMBDA_BUCKET=$DEV_LAMBDA_BUCKET" >> $GITHUB_ENV
          echo "TEST_LAMBDA_BUCKET=$TEST_LAMBDA_BUCKET" >> $GITHUB_ENV
          echo "PROD_LAMBDA_BUCKET=$PROD_LAMBDA_BUCKET" >> $GITHUB_ENV

          cat > ${{ env.ENVIRONMENT }}.hcl <<EOF
          bucket         = "$STATE_BUCKET"
          key            = "${{ env.ENVIRONMENT }}/terraform.tfstate"
          region         = "$REGION"
          dynamodb_table = "$STATE_TABLE"
          encrypt        = true
          EOF

      # Install Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.2" # Pin to specific version

      # Initialize Terraform locally on github runner
      - name: Terraform Init
        run: terraform init -backend-config=${{ env.ENVIRONMENT }}.hcl

      # Plan terraform changes and output to file
      - name: Terraform Plan
        id: plan
        run: terraform plan \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="aws_account_id=${{ vars.AWS_ACCOUNT_ID }}" \
          -var="lambda_code_bucket_dev=${{ env.DEV_LAMBDA_BUCKET }}" \
          -var="lambda_code_bucket_test=${{ env.TEST_LAMBDA_BUCKET }}" \
          -var="lambda_code_bucket_prod=${{ env.PROD_LAMBDA_BUCKET }}" \
          -out=tfplan -lock=false

      # Convert plan to text for PR comment
      - name: Convert plan to text
        run: terraform show -no-color tfplan > tfplan.txt

      # Comment PR with tfplan output
      - name: Comment PR with Plan
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          path: infrastructure/tfplan.txt

  # Third job: Terraform Apply (on pushes to dev/test/main)
  apply:
    runs-on: ubuntu-latest
    needs: [tests] # only run if tests pass
    if: github.event_name == 'push' # only run on push requests

    # necessary to set environment per branch
    environment: ${{ github.ref == 'refs/heads/main' && 'prod' ||
      github.ref == 'refs/heads/test' && 'test' ||
      github.ref == 'refs/heads/dev' && 'dev' }}
    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'prod' ||
        github.ref == 'refs/heads/test' && 'test' ||
        github.ref == 'refs/heads/dev' && 'dev' }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    defaults:
      run:
        working-directory: infrastructure # Keep runs scoped to environment code

    steps:
      # Checkout the repo
      - name: Checkout
        uses: actions/checkout@v4

      # Bundle lambda code
      - name: Zip Lambda code
        working-directory: ./
        run: |
          make -C app/handlers/fruit-api-GET package
          make -C app/handlers/fruit-api-PUT package
          make -C app/handlers/fruit-api-PATCH package
          make -C app/handlers/fruit-api-DELETE package

      # Configure AWS credentials using OIDC
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: "us-east-1" # default region just for the OIDC STS call; set actual region in next step
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/github-oidc-role-${{ env.ENVIRONMENT }}

      # Fetch backend config from SSM
      # - Retrieves global S3/DynamoDB state backend
      # - Creates backend config file for terraform init
      - name: Fetch Backend Config
        run: |
          STATE_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/state-bucket" --query "Parameter.Value" --output text)
          STATE_TABLE=$(aws ssm get-parameter --name "/tf/global-backend/state-table" --query "Parameter.Value" --output text)
          REGION=$(aws ssm get-parameter --name "/tf/global-backend/region" --query "Parameter.Value" --output text)
          DEV_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-dev" --query "Parameter.Value" --output text)
          TEST_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-test" --query "Parameter.Value" --output text)
          PROD_LAMBDA_BUCKET=$(aws ssm get-parameter --name "/tf/global-backend/lambda-code-bucket-prod" --query "Parameter.Value" --output text)

          echo "TF_VAR_state_bucket_name=$STATE_BUCKET" >> $GITHUB_ENV
          echo "DEV_LAMBDA_BUCKET=$DEV_LAMBDA_BUCKET" >> $GITHUB_ENV
          echo "TEST_LAMBDA_BUCKET=$TEST_LAMBDA_BUCKET" >> $GITHUB_ENV
          echo "PROD_LAMBDA_BUCKET=$PROD_LAMBDA_BUCKET" >> $GITHUB_ENV

          cat > ${{ env.ENVIRONMENT }}.hcl <<EOF
          bucket         = "$STATE_BUCKET"
          key            = "${{ env.ENVIRONMENT }}/terraform.tfstate"
          region         = "$REGION"
          dynamodb_table = "$STATE_TABLE"
          encrypt        = true
          EOF

      # Install Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.2" # Pin to specific version of terraform

      # Initialize Terraform locally on github runner
      - name: Terraform Init
        run: terraform init -backend-config=${{ env.ENVIRONMENT }}.hcl

      # Apply terraform changes to build infrastructure using tfvars for environment
      - name: Terraform Apply
        run: |
          terraform apply \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="aws_account_id=${{ vars.AWS_ACCOUNT_ID }}" \
          -var="lambda_code_bucket_dev=${{ env.DEV_LAMBDA_BUCKET }}" \
          -var="lambda_code_bucket_test=${{ env.TEST_LAMBDA_BUCKET }}" \
          -var="lambda_code_bucket_prod=${{ env.PROD_LAMBDA_BUCKET }}" \
          -auto-approve

      # Export Terraform outputs to JSON file
      - name: Export Outputs
        run: terraform output -json > tf_outputs.json

      # Install jq for parsing JSON outputs
      - name: Install jq
        run: sudo apt-get install -y jq

      # Store API DB table in SSM Parameter Store
      - name: Store API DB Table in AWS SSM
        run: |
          APP_TABLE=$(jq -r '.app_db_table_name.value' tf_outputs.json)

          aws ssm put-parameter --name "/tf/global-backend/app-table-${{ env.ENVIRONMENT }}"  --value "$APP_TABLE"  --type String --overwrite
